<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.png >
    <title>
        laotoutou
    </title>
    <meta name="description" content= laotoutou's blog >
    <meta name="keywords" content= laotoutou, 黄志浩, golang >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            为什么sync.Pool使用P个poolLocal
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>看公司项目的日志模块有用到sync.Pool, 觉得有优化的点, 顺便看了看源码, 一边看一边给自己提问题：为什么sync.Pool使用P个poolLocal?</p>
<p>首先看下sync.Pool的用法, 其实对外暴露的就2个方法, Put(), Get()</p>
<p>Get()用于从Pool中获取对象, 并且一般在用完后Put()还回来, 否则下次Get()时会重新创建对象, 失去了Pool存在的价值<br>Pool.New()方法是用户定义的, 用来给sync.Pool增加元素(扩容),</p>
<p>看下sync.Pool结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Pool struct &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	local     unsafe.Pointer &#x2F;&#x2F; local fixed-size per-P pool,  actual type is [P]poolLocal</span><br><span class="line">	localSize uintptr        &#x2F;&#x2F; size of the local array</span><br><span class="line"></span><br><span class="line">	victim     unsafe.Pointer &#x2F;&#x2F; local from previous cycle</span><br><span class="line">	victimSize uintptr        &#x2F;&#x2F; size of victims array</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; New optionally specifies a function to generate</span><br><span class="line">	&#x2F;&#x2F; a value when Get would otherwise return nil.</span><br><span class="line">	&#x2F;&#x2F; It may not be changed concurrently with calls to Get.</span><br><span class="line">	New func() interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码注释, local是一个P大小的poolLocal结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type poolLocal struct &#123;</span><br><span class="line">	poolLocalInternal</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Prevents false sharing on widespread platforms with</span><br><span class="line">	&#x2F;&#x2F; 128 mod (cache line size) &#x3D; 0 .</span><br><span class="line">	pad [128 - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%128]byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Local per-P Pool appendix.</span><br><span class="line">type poolLocalInternal struct &#123;</span><br><span class="line">	private interface&#123;&#125; &#x2F;&#x2F; Can be used only by the respective P.</span><br><span class="line">	shared  poolChain   &#x2F;&#x2F; Local P can pushHead&#x2F;popHead; any P can popTail.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pad是用来解决cpu cache伪共享问题, 32位操作系统的cacheline是64字节, 64位操作系统cacheline 128字节<br>而解决伪共享问题的办法是pad, 避免多个变量共享一个cacheline</p>
<p>真正存放数据用来重用的位置是poolLocalInternal, 看注释其中private结构分别由各自的P使用, 而shard是共享的, 和GPM模型中P的本地goroutine队列和全局goroutine队列有点像(果然天下没有新东西)</p>
<p><strong>private只允许对应的P使用, 再联想GPM模型, 不论有多少个goroutine, cpu一个核心同时只能执行1个goroutine, go程序的同时并行数是P, 不难想到[P]poolLocal的作用是减少锁的争用, 如果sync.Pool只是简单使用链表存储, 那么每次Get()是必然需要加锁, 影响性能</strong></p>
<p>看源码验证下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool) Get() interface&#123;&#125; &#123;</span><br><span class="line">	if race.Enabled &#123;</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	l, pid :&#x3D; p.pin()</span><br><span class="line">	x :&#x3D; l.private</span><br><span class="line">	l.private &#x3D; nil</span><br><span class="line">	if x &#x3D;&#x3D; nil &#123;</span><br><span class="line">		&#x2F;&#x2F; Try to pop the head of the local shard. We prefer</span><br><span class="line">		&#x2F;&#x2F; the head over the tail for temporal locality of</span><br><span class="line">		&#x2F;&#x2F; reuse.</span><br><span class="line">		x, _ &#x3D; l.shared.popHead()</span><br><span class="line">		if x &#x3D;&#x3D; nil &#123;</span><br><span class="line">			x &#x3D; p.getSlow(pid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	if race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		if x !&#x3D; nil &#123;</span><br><span class="line">			race.Acquire(poolRaceAddr(x))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if x &#x3D;&#x3D; nil &amp;&amp; p.New !&#x3D; nil &#123;</span><br><span class="line">		x &#x3D; p.New()</span><br><span class="line">	&#125;</span><br><span class="line">	return x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断private=nil才取shard数据 </p>
<p><em>p.pin()并没有加锁, 只是防止当前goroutine调离P</em></p>
<p>在看shard取数据的操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;</span><br><span class="line">	var slot *eface</span><br><span class="line">	for &#123;</span><br><span class="line">		ptrs :&#x3D; atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		head, tail :&#x3D; d.unpack(ptrs)</span><br><span class="line">		if tail &#x3D;&#x3D; head &#123;</span><br><span class="line">			&#x2F;&#x2F; Queue is empty.</span><br><span class="line">			return nil, false</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Confirm tail and decrement head. We do this before</span><br><span class="line">		&#x2F;&#x2F; reading the value to take back ownership of this</span><br><span class="line">		&#x2F;&#x2F; slot.</span><br><span class="line">		head--</span><br><span class="line">		ptrs2 :&#x3D; d.pack(head, tail)</span><br><span class="line">		if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			&#x2F;&#x2F; We successfully took back slot.</span><br><span class="line">			slot &#x3D; &amp;d.vals[head&amp;uint32(len(d.vals)-1)]</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val :&#x3D; *(*interface&#123;&#125;)(unsafe.Pointer(slot))</span><br><span class="line">	if val &#x3D;&#x3D; dequeueNil(nil) &#123;</span><br><span class="line">		val &#x3D; nil</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Zero the slot. Unlike popTail, this isn&#39;t racing with</span><br><span class="line">	&#x2F;&#x2F; pushHead, so we don&#39;t need to be careful here.</span><br><span class="line">	*slot &#x3D; eface&#123;&#125;</span><br><span class="line">	return val, true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从shard取数据时使用了atomic.CompareAndSwapUint64自旋锁</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2021 | 作者: laotoutou | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="r4ovsx6fID7L4Kk6Ptmojoq3-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="g0CyGSNMSmMSgXBn0zF3jbV9">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>

</body>
</html>
