<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        laotoutou
    </title>
    <meta name="description" content= laotoutou's blog >
    <meta name="keywords" content= laotoutou, 黄志浩, golang >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            redis6.0-zset源码阅读
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>首先redis中的一个key就是redisObject结构, 一个key所属的基本数据类型通过type判断, 一个type如zset的实现方式通过encoding判断, 具体数据在ptr中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS; &#x2F;* LRU time (relative to global lru_clock) or</span><br><span class="line">                            * LFU data (least significant 8 bits frequency</span><br><span class="line">                            * and most significant 16 bits access time). *&#x2F;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>当zset满足以下任一条件时, zset的存储方式是zip list, 以下代码在zadd里面</p>
<ol>
<li>zip list的长度 &gt; 常量server.zset_max_ziplist_entries 默认为128</li>
<li>存储的member长度 &gt; 常量server.zset_max_ziplist_value 默认为64</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||</span><br><span class="line">    sdslen(ele) &gt; server.zset_max_ziplist_value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文重点介绍skip list存储方式, zset的encoding==OBJ_ENCODING_SKIPLIST时, 由字典和跳表组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    sds ele;</span><br><span class="line">    double score;</span><br><span class="line">    &#x2F;&#x2F; 回退结点</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过索引level向前遍历的下一个节点</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned long span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    unsigned long length;</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>下面通过源码查看各个元素所起的作用</p>
<p>本文介绍zset的以下操作:</p>
<ol>
<li>zrank</li>
<li>zrevrange</li>
<li>zadd</li>
</ol>
<p>从搜索开始更容易理解redis的skip list结构</p>
<h2 id="zrank"><a href="#zrank" class="headerlink" title="zrank"></a>zrank</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;zrank&quot;,zrankCommand,3,</span><br><span class="line"> &quot;read-only fast @sortedset&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void zrankCommand(client *c) &#123;</span><br><span class="line">    zrankGenericCommand(c, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void zrevrankCommand(client *c) &#123;</span><br><span class="line">    zrankGenericCommand(c, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zrank逻辑最简单, 看下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">long zsetRank(robj *zobj, sds ele, int reverse) &#123;</span><br><span class="line">    unsigned long llen;</span><br><span class="line">    unsigned long rank;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; zset元素个数</span><br><span class="line">    llen &#x3D; zsetLength(zobj);</span><br><span class="line"></span><br><span class="line">    if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        &#x2F;&#x2F; 忽略zip list的逻辑</span><br><span class="line">    &#125; else if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        &#x2F;&#x2F; skip list是根据score按序存储</span><br><span class="line">        &#x2F;&#x2F; 要根据member查score, 然后才能找到(member, score)对所对应结点的排名</span><br><span class="line">        zset *zs &#x3D; zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl &#x3D; zs-&gt;zsl;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        double score;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; zs-&gt;dict是字典, 根据member通过dict获取对应node</span><br><span class="line">        de &#x3D; dictFind(zs-&gt;dict,ele);</span><br><span class="line">        if (de !&#x3D; NULL) &#123;</span><br><span class="line">            score &#x3D; *(double*)dictGetVal(de);</span><br><span class="line">            &#x2F;&#x2F; 获得排名</span><br><span class="line">            rank &#x3D; zslGetRank(zsl,score,ele);</span><br><span class="line">            &#x2F;* Existing elements always have a rank. *&#x2F;</span><br><span class="line">            serverAssert(rank !&#x3D; 0);</span><br><span class="line">            if (reverse)</span><br><span class="line">                return llen-rank;</span><br><span class="line">            else</span><br><span class="line">                return rank-1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverPanic(&quot;Unknown sorted set encoding&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下score和member对所对应结点的排名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传member是因为zset跳表元素可以重复</span><br><span class="line">unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    unsigned long rank &#x3D; 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    x &#x3D; zsl-&gt;header;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在同一级level中根据score向后查找</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &#x3D;&#x3D; score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;&#x3D; 0))) &#123;</span><br><span class="line">            rank +&#x3D; x-&gt;level[i].span;</span><br><span class="line">            x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* x might be equal to zsl-&gt;header, so test if obj is non-NULL *&#x2F;</span><br><span class="line">        if (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return rank;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 同一级level没找到, 向下一级level查</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结zrank过程:</p>
<p>判断redisObject.encoding, 如果是skip list实现:</p>
<ol>
<li>首先通过字典dict根据member获取对应member的score</li>
<li>然后根据(member, score)从skiplist中查找对应结点的排名</li>
</ol>
<p>由以上过程可以看出skip list的结构和zskiplistNode中各个变量的作用, 对于理解skip list的insert算法有帮助</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    sds ele;</span><br><span class="line">    double score;</span><br><span class="line">    &#x2F;&#x2F; 回退结点(zrevrange回退搜索)</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过索引level向前遍历的下一个节点(根据score查找元素)</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        &#x2F;&#x2F; 距离同级level的上一个结点的步长(利用排名搜索时有用)</span><br><span class="line">        unsigned long span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h2 id="zrevrange"><a href="#zrevrange" class="headerlink" title="zrevrange"></a>zrevrange</h2><p>入口函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;zrevrange&quot;,zrevrangeCommand,-4,</span><br><span class="line"> &quot;read-only @sortedset&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br></pre></td></tr></table></figure>

<p>zrevrange和zrange 调用相同的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void zrangeCommand(client *c) &#123;</span><br><span class="line">    zrangeGenericCommand(c,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void zrevrangeCommand(client *c) &#123;</span><br><span class="line">    zrangeGenericCommand(c,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">void zrangeGenericCommand(client *c, int reverse) &#123;</span><br><span class="line">    robj *key &#x3D; c-&gt;argv[1];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    int withscores &#x3D; 0;</span><br><span class="line">    long start;</span><br><span class="line">    long end;</span><br><span class="line">    long llen;</span><br><span class="line">    long rangelen;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 读取start end (zrevrange key start end)</span><br><span class="line">    if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;start, NULL) !&#x3D; C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[3], &amp;end, NULL) !&#x3D; C_OK)) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提取参数withscores</span><br><span class="line">    if (c-&gt;argc &#x3D;&#x3D; 5 &amp;&amp; !strcasecmp(c-&gt;argv[4]-&gt;ptr,&quot;withscores&quot;)) &#123;</span><br><span class="line">        withscores &#x3D; 1;</span><br><span class="line">    &#125; else if (c-&gt;argc &gt;&#x3D; 5) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((zobj &#x3D; lookupKeyReadOrReply(c,key,shared.emptyarray)) &#x3D;&#x3D; NULL</span><br><span class="line">         || checkType(c,zobj,OBJ_ZSET)) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Sanitize indexes. *&#x2F;</span><br><span class="line">    llen &#x3D; zsetLength(zobj);</span><br><span class="line">    &#x2F;&#x2F; 小于0则表示倒序</span><br><span class="line">    if (start &lt; 0) start &#x3D; llen+start;</span><br><span class="line">    if (end &lt; 0) end &#x3D; llen+end;</span><br><span class="line">    if (start &lt; 0) start &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Invariant: start &gt;&#x3D; 0, so this test will be true when end &lt; 0.</span><br><span class="line">     * The range is empty when start &gt; end or start &gt;&#x3D; length. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 如果为负数则都为负数</span><br><span class="line">    if (start &gt; end || start &gt;&#x3D; llen) &#123;</span><br><span class="line">        addReply(c,shared.emptyarray);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (end &gt;&#x3D; llen) end &#x3D; llen-1;</span><br><span class="line">    rangelen &#x3D; (end-start)+1;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Return the result in form of a multi-bulk reply. RESP3 clients</span><br><span class="line">     * will receive sub arrays with score-&gt;element, while RESP2 returned</span><br><span class="line">     * a flat array. *&#x2F;</span><br><span class="line">    if (withscores &amp;&amp; c-&gt;resp &#x3D;&#x3D; 2)</span><br><span class="line">        addReplyArrayLen(c, rangelen*2);</span><br><span class="line">    else</span><br><span class="line">        addReplyArrayLen(c, rangelen);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 搜索zip list</span><br><span class="line">    if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里忽略了zip list的搜索过程</span><br><span class="line">    &#125; else if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_SKIPLIST) &#123; &#x2F;&#x2F; 搜索skip list</span><br><span class="line">        zset *zs &#x3D; zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl &#x3D; zs-&gt;zsl;</span><br><span class="line">        zskiplistNode *ln; &#x2F;&#x2F; ln存储起始结点</span><br><span class="line">        sds ele;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Check if starting point is trivial, before doing log(N) lookup. *&#x2F;</span><br><span class="line">        if (reverse) &#123;</span><br><span class="line">            &#x2F;&#x2F; zrevrange</span><br><span class="line">            ln &#x3D; zsl-&gt;tail;</span><br><span class="line">            if (start &gt; 0)</span><br><span class="line">                &#x2F;&#x2F; 倒序第llen-start个</span><br><span class="line">                ln &#x3D; zslGetElementByRank(zsl,llen-start);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; zrange</span><br><span class="line">            &#x2F;&#x2F; zsl-&gt;header不存储元素</span><br><span class="line">            ln &#x3D; zsl-&gt;header-&gt;level[0].forward;</span><br><span class="line">            if (start &gt; 0)</span><br><span class="line">                ln &#x3D; zslGetElementByRank(zsl,start+1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 找到了起始结点ln, 还需要从ln向后遍历rangelen个结点</span><br><span class="line">        while(rangelen--) &#123;</span><br><span class="line">            serverAssertWithInfo(c,zobj,ln !&#x3D; NULL);</span><br><span class="line">            ele &#x3D; ln-&gt;ele;</span><br><span class="line">            if (withscores &amp;&amp; c-&gt;resp &gt; 2) addReplyArrayLen(c,2);</span><br><span class="line">            addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            if (withscores) addReplyDouble(c,ln-&gt;score);</span><br><span class="line">            &#x2F;&#x2F; 如果是逆序zrevrange, 下次访问backward</span><br><span class="line">            &#x2F;&#x2F; zrange访问level[0].forward</span><br><span class="line">            ln &#x3D; reverse ? ln-&gt;backward : ln-&gt;level[0].forward;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverPanic(&quot;Unknown sorted set encoding&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过排名查找元素</span><br><span class="line">zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    unsigned long traversed &#x3D; 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    x &#x3D; zsl-&gt;header;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 从同一级level向后查找, 直到traversed大于rank</span><br><span class="line">        &#x2F;&#x2F; traversed记录遍历过的步长</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;&#x3D; rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed +&#x3D; x-&gt;level[i].span;</span><br><span class="line">            x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 找到了对应的排名</span><br><span class="line">        if (traversed &#x3D;&#x3D; rank) &#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结zskiplist的搜索过程:</p>
<p>首先判断redisObject.encoding是skip list的话:</p>
<p>zrevrange和zrange使用相同的搜索逻辑, 都是先通过排名获取起始结点, 再从起始结点向后或向前顺序遍历</p>
<p>利用步长span实现排名搜索, 具体做法是从最高层索引结点开始, 找到下一个步长大于排名的结点, 然后下调一个level继续搜索, 就这样利用span和level往后遍历.</p>
<p>找到起始结点后, 根据是否是reverse搜索, 判断向后还是向前, node-&gt;backward是往回搜索, 向后只能通过level[0]-&gt;forwards</p>
<h2 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h2><p>入口函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;zadd&quot;,zaddCommand,-4,</span><br><span class="line"> &quot;write use-memory fast @sortedset&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br></pre></td></tr></table></figure>

<p>zaddCommand调用zaddGenericCommand, 以下代码比较长但是不复杂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* This generic command implements both ZADD and ZINCRBY. *&#x2F;</span><br><span class="line">void zaddGenericCommand(client *c, int flags) &#123;</span><br><span class="line">    static char *nanerr &#x3D; &quot;resulting score is not a number (NaN)&quot;;</span><br><span class="line">    robj *key &#x3D; c-&gt;argv[1];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    double score &#x3D; 0, *scores &#x3D; NULL;</span><br><span class="line">    int j, elements;</span><br><span class="line">    int scoreidx &#x3D; 0;</span><br><span class="line">    &#x2F;* The following vars are used in order to track what the command actually</span><br><span class="line">     * did during the execution, to reply to the client and to trigger the</span><br><span class="line">     * notification of keyspace change. *&#x2F;</span><br><span class="line">    int added &#x3D; 0;      &#x2F;* Number of new elements added. *&#x2F;</span><br><span class="line">    int updated &#x3D; 0;    &#x2F;* Number of elements with updated score. *&#x2F;</span><br><span class="line">    int processed &#x3D; 0;  &#x2F;* Number of elements processed, may remain zero with</span><br><span class="line">                           options like XX. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Parse options. At the end &#39;scoreidx&#39; is set to the argument position</span><br><span class="line">     * of the score of the first score-element pair. *&#x2F;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 最后scoreidx将定位到第一个score-member对的score位置;</span><br><span class="line">     *</span><br><span class="line">     * ZADD_*常量和flag |&#x3D;的意义是标记flag包含ZADD_*常量,</span><br><span class="line">     * 用来在以后通过&amp;元算的结果是否&#x3D;0来判断是否包含ZADD_* </span><br><span class="line">     * stackoverflow有对应的解释:https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14295469&#x2F;what-does-mean-pipe-equal-operator</span><br><span class="line">     * *&#x2F;</span><br><span class="line">    scoreidx &#x3D; 2;</span><br><span class="line">    while(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        char *opt &#x3D; c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        if (!strcasecmp(opt,&quot;nx&quot;)) flags |&#x3D; ZADD_NX;</span><br><span class="line">        else if (!strcasecmp(opt,&quot;xx&quot;)) flags |&#x3D; ZADD_XX;</span><br><span class="line">        else if (!strcasecmp(opt,&quot;ch&quot;)) flags |&#x3D; ZADD_CH;</span><br><span class="line">        else if (!strcasecmp(opt,&quot;incr&quot;)) flags |&#x3D; ZADD_INCR;</span><br><span class="line">        else break;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Turn options into simple to check vars. *&#x2F;</span><br><span class="line">    int incr &#x3D; (flags &amp; ZADD_INCR) !&#x3D; 0;</span><br><span class="line">    int nx &#x3D; (flags &amp; ZADD_NX) !&#x3D; 0;</span><br><span class="line">    int xx &#x3D; (flags &amp; ZADD_XX) !&#x3D; 0;</span><br><span class="line">    int ch &#x3D; (flags &amp; ZADD_CH) !&#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* After the options, we expect to have an even number of args, since</span><br><span class="line">     * we expect any number of score-element pairs. *&#x2F;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 偶数且不为0个score-member对, 否则向客户端抛异常, 因为zadd的(member, score)成对出现</span><br><span class="line">     * *&#x2F;</span><br><span class="line">    elements &#x3D; c-&gt;argc-scoreidx;</span><br><span class="line">    if (elements % 2 || !elements) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    elements &#x2F;&#x3D; 2; &#x2F;* Now this holds the number of score-element pairs. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Check for incompatible options. *&#x2F;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 同时包含了nx和xx参数</span><br><span class="line">     * *&#x2F;</span><br><span class="line">    if (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            &quot;XX and NX options at the same time are not compatible&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (incr &amp;&amp; elements &gt; 1) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            &quot;INCR option supports a single increment-element pair&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Start parsing all the scores, we need to emit any syntax error</span><br><span class="line">     * before executing additions to the sorted set, as the command should</span><br><span class="line">     * either execute fully or nothing at all. *&#x2F;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 从参数argv获取score数据存放到scores数组中</span><br><span class="line">     * *&#x2F;</span><br><span class="line">    scores &#x3D; zmalloc(sizeof(double)*elements);</span><br><span class="line">    for (j &#x3D; 0; j &lt; elements; j++) &#123;</span><br><span class="line">        if (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*2],&amp;scores[j],NULL)</span><br><span class="line">            !&#x3D; C_OK) goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Lookup the key and create the sorted set if does not exist. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 根据key从redis中获取redisObject</span><br><span class="line">    zobj &#x3D; lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    if (zobj &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; xx参数并且不存在这个zset</span><br><span class="line">        if (xx) goto reply_to_client; &#x2F;* No key + XX option: nothing to do. *&#x2F;</span><br><span class="line">        if (server.zset_max_ziplist_entries &#x3D;&#x3D; 0 ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+1]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 满足创建zip list的条件</span><br><span class="line">            zobj &#x3D; createZsetObject();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 否则创建skip list</span><br><span class="line">            zobj &#x3D; createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建一个zset</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; key存在, 但是类型不是ZSET</span><br><span class="line">        if (zobj-&gt;type !&#x3D; OBJ_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 往zset中批量添加元素</span><br><span class="line">    for (j &#x3D; 0; j &lt; elements; j++) &#123;</span><br><span class="line">        double newscore;</span><br><span class="line">        score &#x3D; scores[j];</span><br><span class="line">        int retflags &#x3D; flags;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; member</span><br><span class="line">        ele &#x3D; c-&gt;argv[scoreidx+1+j*2]-&gt;ptr;</span><br><span class="line">        &#x2F;&#x2F; zset中逐个添加元素</span><br><span class="line">        int retval &#x3D; zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        if (retval &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        if (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        if (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        if (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score &#x3D; newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty +&#x3D; (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    if (incr) &#123; &#x2F;* ZINCRBY or INCR option. *&#x2F;</span><br><span class="line">        if (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        else</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; else &#123; &#x2F;* ZADD. *&#x2F;</span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    if (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? &quot;zincr&quot; : &quot;zadd&quot;, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下方法我忽略了zip list的insert逻辑, 但是这里会有个是否将zip list转化为skip list的判断, 判断条件在文章开头给出了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) &#123;</span><br><span class="line">    &#x2F;* Turn options into simple to check vars. *&#x2F;</span><br><span class="line">    int incr &#x3D; (*flags &amp; ZADD_INCR) !&#x3D; 0;</span><br><span class="line">    int nx &#x3D; (*flags &amp; ZADD_NX) !&#x3D; 0;</span><br><span class="line">    int xx &#x3D; (*flags &amp; ZADD_XX) !&#x3D; 0;</span><br><span class="line">    *flags &#x3D; 0; &#x2F;* We&#39;ll return our response flags. *&#x2F;</span><br><span class="line">    double curscore;</span><br><span class="line"></span><br><span class="line">    &#x2F;* NaN as input is an error regardless of all the other parameters. *&#x2F;</span><br><span class="line">    if (isnan(score)) &#123;</span><br><span class="line">        *flags &#x3D; ZADD_NAN;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Update the sorted set according to its encoding. *&#x2F;</span><br><span class="line">    if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        &#x2F;&#x2F; 忽略了zip list的逻辑</span><br><span class="line">    &#125; else if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs &#x3D; zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de &#x3D; dictFind(zs-&gt;dict,ele);</span><br><span class="line">        if (de !&#x3D; NULL) &#123;</span><br><span class="line">            &#x2F;* NX? Return, same element already exists. *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; zset不存在member, 但是设置了nx参数</span><br><span class="line">            if (nx) &#123;</span><br><span class="line">                &#x2F;&#x2F; 标记ZADD_NOP</span><br><span class="line">                *flags |&#x3D; ZADD_NOP;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            curscore &#x3D; *(double*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            &#x2F;* Prepare the score for the increment if needed. *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; 设置了incr参数</span><br><span class="line">            if (incr) &#123;</span><br><span class="line">                score +&#x3D; curscore;</span><br><span class="line">                if (isnan(score)) &#123;</span><br><span class="line">                    *flags |&#x3D; ZADD_NAN;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newscore) *newscore &#x3D; score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* Remove and re-insert when score changes. *&#x2F;</span><br><span class="line">            if (score !&#x3D; curscore) &#123;</span><br><span class="line">                &#x2F;&#x2F; 更新zset的skip list对应结点的score</span><br><span class="line">                znode &#x3D; zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                &#x2F;* Note that we did not removed the original element from</span><br><span class="line">                 * the hash table representing the sorted set, so we just</span><br><span class="line">                 * update the score. *&#x2F;</span><br><span class="line">                &#x2F;&#x2F; 以上函数更新了skip list, 但是skiplist编码的zset由一个字典和一个skip list组成</span><br><span class="line">                dictGetVal(de) &#x3D; &amp;znode-&gt;score; &#x2F;* Update score ptr. *&#x2F;</span><br><span class="line">                *flags |&#x3D; ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (!xx) &#123; &#x2F;&#x2F; zset不存在这个member, 且没有设置xx参数(xx表示只有存在才更新)</span><br><span class="line">            ele &#x3D; sdsdup(ele);</span><br><span class="line">            &#x2F;&#x2F; 插入跳表</span><br><span class="line">            znode &#x3D; zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            &#x2F;&#x2F; 插入字典</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) &#x3D;&#x3D; DICT_OK);</span><br><span class="line">            *flags |&#x3D; ZADD_ADDED;</span><br><span class="line">            if (newscore) *newscore &#x3D; score;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *flags |&#x3D; ZADD_NOP;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverPanic(&quot;Unknown sorted set encoding&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; &#x2F;* Never reached. *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>更新skip list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注释说调用这个方法需要调用方保证skip list中含有这个元素</span><br><span class="line">zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    &#x2F;* We need to seek to element to update to start: this is useful anyway,</span><br><span class="line">     * we&#39;ll have to update or remove it. *&#x2F;</span><br><span class="line">    x &#x3D; zsl-&gt;header;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score &#x3D;&#x3D; curscore &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</span><br><span class="line">        &#123;</span><br><span class="line">            x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; update记录搜索member过程中, 从0到level各层的转折点(我自己这么叫的)</span><br><span class="line">        update[i] &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Jump to our element: note that this function assumes that the</span><br><span class="line">     * element with the matching score exists. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; x指向的是目标结点</span><br><span class="line">    x &#x3D; x-&gt;level[0].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore &#x3D;&#x3D; x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) &#x3D;&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;* If the node, after the score update, would be still exactly</span><br><span class="line">     * at the same position, we can just update the score without</span><br><span class="line">     * actually removing and re-inserting the element in the skiplist. *&#x2F;</span><br><span class="line">    if ((x-&gt;backward &#x3D;&#x3D; NULL || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">        (x-&gt;level[0].forward &#x3D;&#x3D; NULL || x-&gt;level[0].forward-&gt;score &gt; newscore))</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 需要给目标元素加score, 且目标元素的下一个结点的score &gt; 目标元素, 这种情况直接修改score, 不需要删除再插入</span><br><span class="line">        x-&gt;score &#x3D; newscore;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* No way to reuse the old node: we need to remove and insert a new</span><br><span class="line">     * one at a different place. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 不能重复使用旧结点的情况(需要更新跳表的结构, 包括索引)</span><br><span class="line">    &#x2F;&#x2F; 直接删除再插入</span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode &#x3D; zslInsert(zsl,newscore,x-&gt;ele);</span><br><span class="line">    &#x2F;* We reused the old node x-&gt;ele SDS string, free the node now</span><br><span class="line">     * since zslInsert created a new one. *&#x2F;</span><br><span class="line">    x-&gt;ele &#x3D; NULL;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>插入skip list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    int i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x &#x3D; zsl-&gt;header;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;* store rank that is crossed to reach the insert position *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; rank[0]代表了要插入元素的排名, rank[i]记录了从head到update[i]的步长</span><br><span class="line">        rank[i] &#x3D; i &#x3D;&#x3D; (zsl-&gt;level-1) ? 0 : rank[i+1];</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score &#x3D;&#x3D; score &amp;&amp;</span><br><span class="line">                    &#x2F;&#x2F; 元素相同的话按字典序从小到大</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] +&#x3D; x-&gt;level[i].span;</span><br><span class="line">            x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; update数组记录搜索member所在位置时在level数组中的转折点</span><br><span class="line">        update[i] &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* we assume the element is not already inside, since we allow duplicated</span><br><span class="line">     * scores, reinserting the same element should never happen since the</span><br><span class="line">     * caller of zslInsert() should test in the hash table if the element is</span><br><span class="line">     * already inside or not. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取随机层数</span><br><span class="line">    level &#x3D; zslRandomLevel();</span><br><span class="line">    if (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成的随机层数 &gt; 目前跳表的最高层</span><br><span class="line">        for (i &#x3D; zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] &#x3D; 0;</span><br><span class="line">            update[i] &#x3D; zsl-&gt;header;</span><br><span class="line">            &#x2F;&#x2F; 先初始化为zsl-&gt;length, 下面会更新</span><br><span class="line">            update[i]-&gt;level[i].span &#x3D; zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level &#x3D; level;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 为node分配内存</span><br><span class="line">    x &#x3D; zslCreateNode(level,score,ele);</span><br><span class="line">    &#x2F;&#x2F; 把x插入到update[i]后面</span><br><span class="line">    for (i &#x3D; 0; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward &#x3D; update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward &#x3D; x;</span><br><span class="line"></span><br><span class="line">        &#x2F;* update span covered by update[i] as x is inserted here *&#x2F;</span><br><span class="line">        x-&gt;level[i].span &#x3D; update[i]-&gt;level[i].span - (rank[0] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span &#x3D; (rank[0] - rank[i]) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* increment span for untouched levels *&#x2F;</span><br><span class="line">    for (i &#x3D; level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; backward是回退指针</span><br><span class="line">    x-&gt;backward &#x3D; (update[0] &#x3D;&#x3D; zsl-&gt;header) ? NULL : update[0];</span><br><span class="line">    if (x-&gt;level[0].forward)</span><br><span class="line">        &#x2F;&#x2F; 设置下一个结点的backward指针</span><br><span class="line">        x-&gt;level[0].forward-&gt;backward &#x3D; x;</span><br><span class="line">    else</span><br><span class="line">        zsl-&gt;tail &#x3D; x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="为什么zset使用跳表而不是平衡二叉树-如红黑树-B树"><a href="#为什么zset使用跳表而不是平衡二叉树-如红黑树-B树" class="headerlink" title="为什么zset使用跳表而不是平衡二叉树, 如红黑树, B树"></a>为什么zset使用跳表而不是平衡二叉树, 如红黑树, B树</h3><p><a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=1171423">https://news.ycombinator.com/item?id=1171423</a></p>
<p>有人关于skiplist提了自己的几点质疑:</p>
<ol>
<li>skiplist 会因为指针比b树占用更多内存</li>
<li>没有利用局部性原理导致cache失效</li>
</ol>
<p>另外建议创建多个线程提高cpu利用率和吞吐量</p>
<p>作者回答:</p>
<ol>
<li>zset的skip list的索引结点数量是可控制的, 可以通过ZSKIPLIST_P控制, 从而优化内存占用</li>
<li>sorted set的常用操作是按序遍历, 也就是说将跳跃表作为链表遍历. 这个操作在缓存命中上不比平衡树差</li>
<li>skip list很容易实现, 调试, 方便扩展</li>
</ol>
<p>关于线程, 作者说经验表明redis的瓶颈在I/O, 假设你的服务能让单核满负载, 可以在同一台机器部署多个redis实例, 使用redis cluster</p>
<h3 id="redis的zset实现的skiplist做了哪些优化"><a href="#redis的zset实现的skiplist做了哪些优化" class="headerlink" title="redis的zset实现的skiplist做了哪些优化"></a>redis的zset实现的skiplist做了哪些优化</h3><ol>
<li>member可以重复, 重复元素根据字典序排序</li>
<li>增加后退指针, 可以在zrevrange操作中, 找到起始结点后利用后退指针backward回退查找</li>
</ol>
<p>参考</p>
<p>原论文地址: <a target="_blank" rel="noopener" href="http://homepage.cs.uiowa.edu/~ghosh/skip.pdf">Skip Lists:A Probabilistic Alternative to Balanced Trees</a></p>
<p><a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=1171423">作者关于为什么使用skiplist的说明</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14295469/what-does-mean-pipe-equal-operator">stackoverflow关于位运算 |= 的解释</a></p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: laotoutou | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="r4ovsx6fID7L4Kk6Ptmojoq3-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="g0CyGSNMSmMSgXBn0zF3jbV9">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
</body>
</html>
