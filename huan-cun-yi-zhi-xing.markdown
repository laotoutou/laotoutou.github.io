---
title: 对缓存一致性的思考
date: 2021-03-06 02:54:00
tags:
- redis
---

缓存一致性是个比较有争议的问题, 首先说为什么用缓存?

* 高性能: redis基于内存, 查询效率相比查磁盘的mysql更快
* 高并发: redis可以支持更多的并发查询


那么同一份数据分别存储在redis和mysql服务器, 如何保证数据一致性?

先说结论: 根据分布式CAP理论, 无法做到强一致性! 不过可以做到最终一致性


关于一致性的3个级别:

* 强一致性
* 弱一致性
* 最终一致性


关于CAP的说明

* C一致性. 指不同实例保存的同一份数据是一致的
* A可用性. 指任何时候可以向客户端返回数据
* P分区容错性. 指的是由于网络等原因导致不同实例通讯故障

不同实例之间网络故障等问题是不可避免的, 因此要考虑到这种情况, 也就是要满足分区容错性. 因此cap理论就是在ca之间权衡

* 保证可用性而牺牲一致性: 服务端需要向调用方返回数据而不能出现不可用的情况, 那么就不能考虑一致性, 即不论数据是否一致都需要给响应
* 保证一致性而牺牲可用性: 对于强一致性场景, 需要阻塞调用方请求直到数据恢复一致性, 那么这就牺牲了可用性

**考虑到使用缓存的业务场景是为了支持大量并发, 如果出现了不可用的情况, 不如直接限速限制客户端请求, 因此我们需要牺牲一致性来满足可用性和分区容错性**

能做到的就是尽量使得数据一致, 即如何做到最终一致性

1. 删缓存还是更新缓存
2. 先mysql还是先redis

## 删缓存还是更新缓存

更新缓存在并发情况下会出现2个问题

1. 多线程下更新顺序的问题: A先发起更新操作, B随后发起更新, 但是由于网络等原因, B的请求先被执行了, 那么缓存中留下来的就是A的数据
2. 业务上频繁更新数据而请求量较少, 导致资源浪费; 要被更新的新数据可能需要经过复杂的计算, 每次操作浪费资源

结论: 采用cache aside方式, 即删除缓存

## 先mysql还是先redis

#### 先删除缓存再更新数据库

这种方式在多线程下的问题:

A删除了缓存还没来得及更新数据库时, B请求未命中缓存, 从mysql中读取数据写入redis. 到此不一致发生了

这种不一致发生的条件: 查redis未命中的时间+查mysql时间 < 写mysql时间

解决方案:

延迟双删: 删除缓存后更新数据库, 然后sleep一段时间再次删除缓存(删缓存失败了怎么办)


#### 先更新数据库再删除缓存

也有个并发情况下的问题: A更新数据库之前缓存失效了, 这时候B线程读取mysql数据读到了旧值, A更新数据库并删除了缓存, B把读到的旧值写入缓存

这种情况出现的条件: 读mysql时间 > 更新mysql时间+删除缓存时间 (几率较低)

还有另一个同样的问题是**缓存更新失败了怎么办**, 这个问题同样也会在先删缓存再更新数据库的延时双删策略中出现

对于删除缓存失败的问题, 业界给出的解决方案是采用消息队列重试机制
