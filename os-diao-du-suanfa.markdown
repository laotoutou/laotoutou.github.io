---
title: 操作系统调度算法
date: 2021-02-17 19:28:00
tags:
- os
---


## 调度目标

* 性能指标. 周转时间, 响应时间
* 公平指标. 如果给每个任务分配的cpu时间是相同的就是完全公平的

周转时间: 任务完成时间 - 任务创建的时间

响应时间: 任务首次运行的时间 - 任务创建的时间

性能指标和公平指标是矛盾的, 要提高性能意味着阻止一些任务的运行, 这就降低了公平性

## 调度算法

名称 | 英文 | 详情 | 优点 | 缺点 
---- | ---- | ---- | ---- | ----
先进先出/先到先服务 | first in first out / first come first served  | 按照任务创建时间依次运行 | 简单 | 不利于周转时间. 对于耗时较长的任务会阻塞后面任务的执行 
最短任务优先 | shortest job first  | 先运行耗时最短的任务, 然后是次短的任务. 不可抢占的调度 | 周转时间: sjf < fifo | 1. 任务并不总是同时创建, 执行时间短的任务创建时间可能小于当前正在执行的任务<br> 2. 没有先验知识, 不能预先得知任务执行时间
最短完成时间优先 / 抢占式最短作业优先 | shortest time-to-completion first / preemptive shortest job first | 当新任务进入系统时, 确定剩余工作和新工作中, 谁的剩余时间最少, 然后调度该工作 | 支持抢占, 所以周转时间: stcf < sjf | 1. 不能预先得知任务执行时间<br> 2. 不利于响应时间
轮转 | round-robin | 在一个时间片运行一个任务, 然后切换到运行队列中的下一个任务. 时间片长度必须是始终中断周期的倍数 | 良好的响应时间 | 1. 不利于周转时间<br> 2. 带来上下文切换开销
多级反馈队列 | multi-level feedback queue | 拥有许多独立的队列, 每个队列有不同的优先级. 任何时刻一个工作只能存在于一个队列中, 总是优先执行高优先级的工作 | - | -


多级反馈队列准则:

1. 如果a的优先级 > b的优先级, 那么运行a
2. 如果a和b的优先级相等, 那么轮转运行a和b

多级反馈队列优先级调整策略:

1. 任务创建时, 放在最高优先级
2. 一旦任务用完了在某一优先级中的时间配额, 就降低其优先级
3. 经过一段时间就将系统中所有任务重新加入最高优先级


多级反馈队列通过将刚创建的任务放入最高优先级, 并在一个时间片后降低优先级的方式解决了任务刚创建时, 无法获知运行时间的问题.

总结:

1. 优化周转时间: 最短作业优先, 最短完成时间优先 
2. 优化响应时间: 轮转
3. 多级反馈队列通过设置不同优先级队列以及优先级调整策略优化平均响应时间和周转时间


## 多处理器调度

多处理器需要考虑的问题:

1. 同步. cpu通过mesi协议实现cpu缓存的一致性; os仍然需要通过互斥原语实现访问共享内存的一致性
2. 缓存亲和度. 一个进程在不同的cpu上运行, 会由于重新加载cpu缓存数据而很慢

名称 | 英文 | 详情 | 优点 | 缺点 
---- | ---- | ---- | ---- | ----
单队列调度 | single queue multiprocessor scheduling | 将所有需要调度的任务放入单独队列中 | 简单 | 1. 需要加锁导致缺乏可扩展性<br> 2. 不利于缓存亲和性
多队列调度 | multi-queue multiprocessor scheduling | 包含多个调度队列, 每个队列可以使用不同的调度规则, 每个cpu之间相互独立, 避免同步问题 | 具备可扩展性和缓存亲和度 | 负载不均(可以通过working stealing解决)

多队列调度如何解决负载不均的问题:

采用工作窃取working stealing技术, 队列较少的cpu不定期检查其他cpu的工作队列, 从其他cpu的工作队列中窃取一个或多个工作实现负载均衡. 如果检查太频繁会由于同步问题导致扩展性不好, 时间间隔太长会导致负载不均


## linux多处理器调度

> Linux中调度器的设计，引入的概念
> 
> * 普通进程和实时进程使用优先级区分，0-99表示实时进程，100-139表示普通进程
> * 实时进程采用两种调度策略SCHED_RR或者SCHED_FIFO
> * 普通进程采用nice值进行动态调整普通进程的优先级
> * 经常睡眠的进程尝试增大下优先级，经常长占CPU的适当减少优先级


### O(n)调度程序

这是linux早期的调度程序, O(n)指的是时间复杂度是O(n), 调度器定义一个调度队列, 不管是实时进程还是普通进程都会加入这个队列

存在的问题:

1. 每次调度选择下一个运行进程时, 需要从头到尾遍历运行队列, 时间复杂度高
2. 多个cpu核心都会访问同一个调度队列, 互斥原语影响性能
3. 进程在多个核心跳跃, 不利于缓存亲和度


### O(1)调度程序

为解决O(n)调度器存在的问题, 引入O(1)调度器:

每个cpu核心维护2个链表, 一个是active链表, 存储代运行的进程; 一个是expire链表, 存储时间片用完的进程.

每个链表按照140个优先级(0-99, 100-139)存储, 相同优先级的进程挂载在相同结点上

同时为了解决O(n)复杂度的问题, 维护一个140位的bitmap, 选择下一个运行进程的时候取bitmap的最高位为1的优先级, 从这个优先级中按照调度算法选择下一个运行的进程

当active中可运行进程为空时, 表明所有进程的时间片已经耗光, 这时候对换active和expire指针


### 完全公平调度Completely Fair Scheduler CFS

> 完全公平调度器(CFS)最早是在2017年merged进Linux2.6.23版本中的，一直到现在都是系统中默认的调度器

O(n)调度和O(1)调度本质上都是基于优先级的调度, 而CFS调度是基于比例调度的方法

通过引入vruntime将进程运行时间标准化, 进程对应的vruntime越小, 表明消耗的cpu资源越少. 通过比较vruntime得知进程消耗cpu资源的多少, 进而选择下一个应该执行的进程. 

vruntime = 实际运行时间 * 1024 / 进程权重

参考

《操作系统导论》

[linux O(1)调度器](https://cloud.tencent.com/developer/article/1603981)

[linux O(n)调度器](https://cloud.tencent.com/developer/article/1603917)

[linux公平调度CFS原理](https://www.jianshu.com/p/673c9e4817a8)
